<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Building API clients in Rust</title>
    <meta name="description" content="January monthly meetup">
    <meta name="author" content="wafflespeanut">
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link rel="stylesheet" href="../../css/reveal.css">
    <link rel="stylesheet" href="../../css/theme/simple.css" id="theme">
    <link rel="stylesheet" href="../../lib/css/zenburn.css">
    <link rel="stylesheet" href="../shared/custom.css">
    <script>
      if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = '../../css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
      }
    </script>
  </head>

  <body>
    <div class="reveal">
      <div class="slides">
        <section data-background="../shared/images/logo.png" data-background-size="12vw" data-background-position="44vw 5vh">
          <br />
          <br />
          <h3>Building API clients in Rust</h3>
            <pre><code class="rust">
    fn main() {
        let client = reqwest::Client::new();
        let f = Object::create()
                       .with_name("foo")
                       .from_file("/path/to/file")
                       .using(&client);
    }
              </code></pre>
          <p>
            <small><a href="https://twitter.com/wafflespeanut">@wafflespeanut</a></small>
          </p>
        </section>
        <section>
          <h3>Case study: Azure Resource Group</h3>
          <pre style="font-size: 1vw"><code class="bash">
  API_URL="https://management.azure.com/subscriptions/$SUBSCRIPTION"

  curl -X PUT -H "Authorization: Bearer $OAUTH_TOKEN" \
    -H "Content-Type: application/json" -d '{"location": "northeurope"}' \
    $API_URL/resourcegroups/my-group?api-version=2020-06-01
          </code></pre>
        </section>
        <section>
          <h3>Good old way...</h3>
          <pre><code class="rust">
  let client = AzClient::new(
      "tenant-id", "client-id", "secret")?;
  let group = client.create_resource_group(
      "my-subscription", "my-group", "northeurope").await?;
          </code></pre>
        </section>
        <section>
          <h3>New way</h3>
          <pre><code class="rust">
  let client = AzClient::new(
      "tenant-id", "client-id", "secret")?;

  let group = ResourceGroup::create()
                            .with_name("my-group")
                            .in_location("northeurope")
                            .for_subscription("my-sub")
                            .using(&client).await?;
          </code></pre>
        </section>
        <section>
          <h2>Builder pattern</h2>
          <ul>
            <li class="fragment roll-in">Provides encapsulation, verbosity and control over object construction.</li>
            <li class="fragment roll-in">With generics, functionalities can be shared.</li>
            <li class="fragment roll-in">With generics, initialization can be guaranteed.</li>
          </ul>
        </section>
        <section>
          <section>
            <h3>Setup: Builder</h3>
            <pre><code class="rust">
    pub struct ResourceGroup {  // everything's optional, meh.
        group: Option&lt;String&gt;,
        subscription_id: Option&lt;String&gt;,
        location: Option&lt;String&gt;,
    }
            </code></pre>
            <pre class="fragment"><code class="rust">
    impl ResourceGroup {
        pub fn create() -&gt; Self {
            ResourceGroup {
                group: None,
                subscription: None,
                location: None,
            }
        }
    }
            </code></pre>
          </section>
          <section>
            <h3>Setup: Adaptors</h3>
            <pre><code class="rust">
    impl ResourceGroup {
        pub fn with_name(mut self, name: &str) -&gt; Self {
            self.group = Some(name.into());
            self
        }
        pub fn in_location(mut self, id: &str) -&gt; Self {
            self.location = Some(id.to_owned());
            self
        }
        pub fn for_subscription(mut self, id: &str) -&gt; Self {
            self.subscription_id = Some(id.to_owned());
            self
        }
    }
            </code></pre>
          </section>
          <section>
            <h3>Setup: Client</h3>
            <pre><code class="rust">
    /// Wrapper over HTTP client configured for API
    pub struct AzClient { /* */ }
            </code></pre>
            <pre class="fragment"><code class="rust">
    trait ApiClient {
        type Request;
        type Response;

        fn request(&self, method: http::Method, url: &str)
                  -&gt; Self::Request;

        async fn fetch(&self, req: Self::Request)
                      -&gt; Result&lt;Self::Response, MyError&gt;
    }
            </code></pre>
            <pre class="fragment"><code class="rust">
    impl ApiClient for AzClient { /* impl */ }
            </code></pre>
          </section>
          <section>
            <h3>Setup: API caller</h3>
            <pre><code class="rust">
  pub trait Sendable&lt;C: ApiClient&gt; {
    type Output: serde::de:DeserializeOwned;

    const METHOD: http::Method;

    fn rel_path(&self) -&gt; String;

    fn modify(&self, req: C::Request) -&gt; Client::Request;
        </code></pre>
        <pre class="fragment"><code class="rust">
    async fn using(&self, client: &C) -&gt; Result&lt;Self::Output&gt {
        let req = self.modify(client.request());
        let resp = client.fetch(req).await?;
        let bytes = resp.body_bytes().await?;
        Ok(serde_json::from_reader(bytes.as_ref())?)
    }
  }
            </code></pre>
          </section>
          <section>
            <h3>Setup: API objects</h3>
            <pre class="fragment" data-fragment-index="1"><code class="rust">
  impl Sendable&lt;C: ApiClient&gt; for ResourceGroup {
      type Output = ResourceGroup;

      const METHOD = http::Method::PUT;

      fn rel_path(&self) -&gt; String {
          format!(
              "/resourcegroups/{}?api-version=2020-06-01",
              self.group)
      }
  }
            </code></pre>
            <p class="fragment" data-fragment-index="1">And voila!</p>
          </section>
        </section>
        <section>
          <section>
            <h3>Problem #1</h3>
            <p class="fragment roll-in">We can't use <code>ResourceGroup</code> for any other API calls!</p>
            <p class="fragment">Can we take advantange of the type system?</p>
          </section>
          <section>
            <p>Phantom types!</p>
            <pre class="fragment"><code class="rust">
  pub struct Wrapper&lt;A, M&gt; {
      _marker: PhantomData&lt;A&gt;,
      object: M,
  }
            </code></pre>
            <pre class="fragment"><code class="rust">
  impl&lt;A, M&gt; Deref for Wrapper&lt;A, M&gt; { /* read access */ }

  impl&lt;A, M&gt; DerefMut for Wrapper&lt;A, M&gt; { /* write access */ }
            </code></pre>
            <pre class="fragment"><code class="rust">
  impl&lt;A, M&gt; From&lt;M&gt; for Wrapper&lt;A, M&gt; {
      fn from(object: M) -&gt; Self {
          Wrapper {
              object,
              _marker: PhantomData,
          }
      }
  }
            </code></pre>
          </section>
          <section>
            <h3>And?</h3>
            <p class="fragment">Add unit structs...</p>
            <pre class="fragment"><code class="rust">
  pub struct Create;
            </code></pre>
            <p class="fragment">Now, <code>ResourceGroup</code> creation becomes...</p>
            <pre class="fragment"><code class="rust">
  impl ResourceGroup {
      pub fn create() -&gt; Wrapper&lt;Create, ResourceGroup&gt; {
          Wrapper::from(ResourceGroup {
              group: None,
              subscription_id: None,
              location: None,
          })
      }
  }
            </code></pre>
          </section>
          <section>
            <p>Action-specific functionaliy...</p>
            <pre><code class="rust">
  impl Wrapper&lt;Create, ResourceGroup&gt; {
      pub fn in_location(mut self, id: &str) -&gt; Self {
        self.location = Some(id.to_owned());
        self
      }
  }
            </code></pre>
            <pre class="fragment"><code class="rust">
  impl&lt;A&gt; Wrapper&lt;A, ResourceGroup&gt; {
      pub fn for_subscription(mut self, id: &str) -&gt; Self {
        self.subscription_id = Some(id.to_owned());
        self
      }
  }
            </code></pre>
          </section>
          <section>
            <p>Implement API call for the wrapper...</p>
            <pre><code class="rust">
  impl Sendable for Wrapper&lt;Create, ResourceGroup&gt;{
      type Output = ResourceGroup;

      const METHOD = http::Method::PUT;

      fn rel_path(&self) -&gt; String {
          format!(
              "/resourcegroups/{}?api-version=2020-06-01",
              self.group)
      }
  }
            </code></pre>
          </section>
        </section>
        <section>
          <section>
            <p>
              <strong>Disclaimer:</strong> The following slides only show what's
              possible in the Rust type system and was made for fun.
            </p>
            <p>It's not intended to be taken seriously and certainly not intended to scare people away.</p>
            <p>Please don't try this at home, and especially if you're having a bad day already.</p>
          </section>
          <section>
            <h3>Problem #2</h3>
            <p class="fragment roll-in">Is it possible to guarantee the existence of required properties, like name, subscription or location?</p>
            <strong class="fragment">At compile time???</strong>
          </section>
          <section>
            <h3>More markers!</h3>
            <pre class="fragment"><code class="rust">
    pub struct NameExists;
    pub struct NameMissing;
    pub struct LocationExists;
    pub struct LocationMissing;
    pub struct SubscriptionExists;
    pub struct SubscriptionMissing;
            </code></pre>
            <pre class="fragment"><code class="rust">
  pub struct ResourceGroupCreateBuilder&lt;N, L, S&gt; {
      object: ResourceGroup,
      _g: PhantomData&lt;N&gt;,
      _s: PhantomData&lt;S&gt;,
      _l: PhantomData&lt;L&gt;,
  }
            </code></pre>
          </section>
          <section>
            <pre><code class="rust">
  impl ResourceGroup {
      pub fn create() -&gt; ResourceGroupCreateBuilder&lt;
          NameMissing,
          LocationMissing,
          SubscriptionMissing,
        &gt;
      {
        ResourceGroupCreateBuilder {
            object: ResourceGroup::default(),
            /* PhantomData fields */
        }
      }
  }
            </code></pre>
          </section>
          <section>
            <pre><code class="rust">
  impl&lt;N, L, S&gt; ResourceGroupCreateBuilder&lt;N, L, S&gt; {
      pub fn with_name(mut self, name: &str)
        -&gt; ResourceGroupCreateBuilder&lt;NameExists, L, S&gt;
      {
          self.group = Some(name.into());
          unsafe { mem::transmute(self) }
      }
  }
            </code></pre>
          </section>
          <section>
            <p>Allow API call only when everything exists!</p>
            <pre><code class="rust">
    impl Sendable for ResourceGroupCreateBuilder&lt;
        NameExists,
        LocationExists,
        SubscriptionExists,
      &gt;
    {
        /* impl */
    }
            </code></pre>
          </section>
          <section>
            <p>Try using the wrong way?</p>
            <pre><code class="rust">
    let rg = ResourceGroup::create().using(&client).await?;
            </code></pre>
            <code class="fragment rust-error">error[E0599]: no method named `send` found for struct `ResourceGroupCreateBuilder&lt;NameMissing, LocationMissing,
                SubscriptionMissing&gt;` in the current scope</code>
          </section>
        </section>
        <section>
          <p>What if all of this is already done by a crate?<p>
          <h3 class="fragment">Check out <a href="https://github.com/wafflespeanut/paperclip/">paperclip</a>!</h3>
        </section>
        <section>
          <h2>Thanks!</h2>
          <p>
            <small><a href="https://twitter.com/wafflespeanut">@wafflespeanut</a></small>
          </p>
        </section>
      </div>
    </div>

    <script src="../../lib/js/head.min.js"></script>
    <script src="../../js/reveal.js"></script>
    <script>

      Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,
        autoSlideStoppable: false,
        transitionSpeed: 'slow',
        mouseWheel: true,
        theme: Reveal.getQueryHash().theme,
        transition: 'none',   // none/fade/slide/convex/concave/zoom

        dependencies: [
          { src: '../../lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: '../../plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: '../../plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: '../../plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: '../../plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
          { src: '../../plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
        ]
      });
    </script>
  </body>
</html>
